Plan
====

trunk vs a branch?
------------------
I believe the end-result will convert a substantial fraction of GCC's
functions into being methods, so this is going to touch a lot of code.

I'm proposing numerous changes here, but I believe each one can be broken
down into self-contained patches.

A few of the changes touch numerous source files.  I'm not sure if this
work can sanely be done on a branch: merging would be too painful.

I intend to never break the build: an evolution of the code towards
statelessness, without big "flag days" or other stuff that makes the tree
unconsumable.

Hence I would prefer that this work go into trunk (targeting 4.9).

However I appreciate:

  * I'm a relative newcomer to GCC development (I'm the author of the
    Python plugin for gcc, and have been working on it for about 2 years),
    but I've only been working on GCC itself for a couple of months.

  * There are performance concerns about these changes.

So what's probably more palatable to the GCC core maintainers is a hybrid:

  * low-risk patches go to trunk

  * higher-risk patches to to a branch

  * split up the work to try to keep the "merge delta" reasonably low: some
    of the changes to trunk will not make sense except as enabling work for
    changes to the branch.

One way of this is:

  * do the conversion of the code to classes on trunk, keeping everything
    as "static":  functions become static methods, global variables become
    static data members.  This should have no performance impact.
    
  * maintain a branch in which the various "static" things above become
    non-static.

Another example, the conversion of passes from C structs to C++ classes
contains a mixture of autogenerated and handwritten code.  Part of this is
a move of the pass tree to a passes.def file - and this needs constant
rebasing as passes get moved around by other gcc developers.  So if I am
destined for a branch, I'd at least want the option of tactical merges
here and there.


Singletons vs non-singletons and performance
--------------------------------------------
A concern about generalizing the code to support multiple states is
the increased register pressure of passing a context pointer around
everywhere.

One way to mitigate this is the static-vs-non-static trick from the
tracer.c thread
http://gcc.gnu.org/ml/gcc-patches/2013-05/msg01351.html::


  #if GLOBAL_STATE
  /* When using global state, all methods and fields of state classes
     become "static", so that there is effectively a single global
     instance of the state, and there is no implicit "this->" being passed
     around.  */
  # define MAYBE_STATIC static
  #else
  /* When using on-stack state, all methods and fields of state classes
     lose the "static", so that there can be multiple instances of the
     state with an implicit "this->" everywhere the state is used.  */
  # define MAYBE_STATIC
  #endif

and then using this within a pass to encapsulate state, either as a
singleton, or with multiple instances::

  class tracer_state
  {
  public:
    tracer_state();
  
    MAYBE_STATIC bool tail_duplicate ();
  
  private:
  
    MAYBE_STATIC edge find_best_successor (basic_block);
    MAYBE_STATIC edge find_best_predecessor (basic_block);
    MAYBE_STATIC int find_trace (basic_block, basic_block *);
    MAYBE_STATIC void mark_bb_seen (basic_block bb);
    MAYBE_STATIC bool bb_seen_p (basic_block bb);
  
  private:
  
    /* Minimal outgoing edge probability considered for superblock
       formation.  */
    MAYBE_STATIC int probability_cutoff;
    MAYBE_STATIC int branch_ratio_cutoff;
  
    /* A bit BB->index is set if BB has already been seen, i.e. it is
       connected to some trace already.  */
    MAYBE_STATIC sbitmap bb_seen;

  }; // tracer_state

Hence we can put a tracer_state on the stack in an execute hook, and it
will be empty in a GLOBAL_STATE build, with all the fields being
effectively globals.

Such classes that are local to a source file should be placed into an
anonymous namespace in order to take advantage of target-specific
optimizations that can be done on purely-local functions::

  namespace {

  class tracer_state
  {
     /* etc */
  }; // tracer_state

  } // anon namespace

Alternatively, Richard Henderson identified another pattern in
http://gcc.gnu.org/ml/gcc-patches/2013-05/msg01415.html ::

  namespace {

  class pass_state
  {
    private:
      int x, y, z;

    public:
      constexpr pass_state()
        : x(0), y(0), z(0)
      { }

      void doit();

    private:
      void a();
      void b();
      void c();
  };

  // ...

  } // anon namespace

  #ifdef GLOBAL_STATE
  static pass_state ps;
  #endif

  void execute_hook()
  {
  #ifndef GLOBAL_STATE
    pass_state ps;
  #endif
    ps.doit();
  }

where the compiler's IPA constant propagation sees that the initial "this"
argument is passed a constant value, letting it propagate and eliminate.

Presumably this only works for the case of state that's in one file and
effectively a local.  For state that persists between invocations (and thus
needs references to it stored somewhere), we need another approach (e.g.
the MAYBE_STATIC approach described above).

"constexpr" was introduced in C++11, so presumably we would need to wrap
it in a macro.

Are there other approaches?

Plan: I'm thinking that we should use a dual approach:

  * rth's approach for "per-invocation" state

  * the MAYBE_STATIC approach for state that needs to be referenced
    by a pass or by the universe/context object.

FWIW I favor putting extra space between the MAYBE_STATIC and the decl,
breaking things up a little makes it easier for me to read the code::

  class callgraph
  {
  public:
    /* Number of nodes in existence.  */
    MAYBE_STATIC  int n_nodes;

    /* Maximal uid used in cgraph nodes.  */
    MAYBE_STATIC  int node_max_uid;

    /* Maximal uid used in cgraph edges.  */
    MAYBE_STATIC  int edge_max_uid;
  };

vs::

  class callgraph
  {
  public:
    /* Number of nodes in existence.  */
    MAYBE_STATIC int n_nodes;

    /* Maximal uid used in cgraph nodes.  */
    MAYBE_STATIC int node_max_uid;

    /* Maximal uid used in cgraph edges.  */
    MAYBE_STATIC int edge_max_uid;
  };



Elimination of singleton lookups
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Given this code::

   unsigned int
   pass_foo::execute_hook(void)
   {
      /* Get the universe as "this->ctxt_" */
      FILE *dump_file = ctxt_.dump_file_;

where `dump_file_` is a MAYBE_STATIC field of a context, I'm hoping
that in a GLOBAL_STATE build the optimizer can
identify that the `ctxt_` isn't used, and optimize away the lookups
as equivalent to::

   unsigned int
   pass_foo::execute_hook(void)
   {
      context &unused = this->ctxt;
      FILE *dump_file = context::dump_file_;

and simply do::

   unsigned int
   pass_foo::execute_hook(void)
   {
      FILE *dump_file = context::dump_file_;

Similarly, consider chains of singletons, e.g.::

  class context
  {
  public:
    MAYBE_STATIC  callgraph cgraph_;
  };

  class callgraph
  {
  public:
    MAYBE_STATIC  int node_max_uid;
  };

and this statement::

  foo ((/*this->*/ctxt_.cgraph_->node_max_uid);

where `ctxt_` is MAYBE_STATIC, this is effectively::

  context& tmpA = this->ctxt_;
  callgraph *tmpB = tmpA.cgraph_;
  int tmpC = tmpB->node_max_uid;
  foo (tmpC);

and static on the fields in a global state build means that this is::

  context& tmpA = this->ctxt_;
  callgraph *tmpB = context::cgraph_;
  int tmpC = callgraph::node_max_uid;

and thus tmpA and tmpB are unused, so this is effectively just::

  int tmpC = callgraph::node_max_uid;
  foo (tmpC);

Is this expectation reasonable?


Other aspects
^^^^^^^^^^^^^
TODO: experience in gdb for each variant?
TODO: experience in valgrind for each variant?
TODO: what about GC-owned objects and the (lack of) stack roots?


A singleton-removal optimization
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Another approach is to create a new optimization pass for GCC:  optimized
handling of singletons that have been marked as such using a new attribute::

  class foo
  {
  } __attribute__((singleton("the_foo"));

The "singleton" attribute tells the C++ compiler that the struct/class
so-marked will only ever have a single instance, a global variable with
the given decl.  Note that the_foo might be a subclass of foo.  The
compiler should issue an error if this contract is violated.

Then all methods of the marked class lose their implicit "this"
parameters (changing ABI, I know), removing them from all callsites
also.  Instead, this local is implicitly injected into the
implementation of each method call::

   foo *this = &the_foo;

So we'd have something like this::

  class universe
  {
  } SINGLETON_IN_STATIC_BUILD("the_uni");

For a library build where universe instances are dynamically-created, the
macro expands away to whitespace, but for a non-library build, this
would expand to the attribute.

This thus:

  * saves the register pressure of passing around around the this ptr
    everywhere when there's only ever one instance

  * allows devirtualization of vfuncs: we *know* the exact subclass of
    the_foo, so any calls to foo or its subclasses must be the_foo.

  * other optimizations?  (e.g. "exploding" a global struct into global
    vars for its fields)

I think this could be used in quite a few places e.g. for universe, for
the pass manager, for the callgraph, for global_options.

I'm also thinking long-term the various tables of hooks should probably
become C++ objects with vtables, so that we can naturally generalize
them to be singletons in the static-build case, but potentially have
several in the gcc-as-library case.

Clearly if we go for this one, writing the implementation is a
significant task.


Bikeshedding: "universe" vs "context"
-------------------------------------
We need a name for the thing that encapsulates the state of the compiler.

I've been flitting between "universe" and "context" for this name.

  * "universe" comes from the term "parallel universe" beloved of sci-fi
    authors

  * "context" is already used in several places within the code for
    something else

  * "context" sometimes makes people think of threads.  I don't see that
    the state needs to be per-thread; it's per-client - a client could
    have multiple threads all using one bundle-of-state (imposing a lock
    client-side)

  * "universe" nicely conveys the idea that different universes are
    separate, that you can't share things between universes.

  * "context" is the more traditional term; "universe" might seem rather
    weird.

Another bikeshed discussion is what to call the global singleton instance.
Ideas include:

  * `the_uni`

  * `the_ctxt`

  * `the_ctx`

  * `ctx`

  * `gcc`

  * `g` (minimal typing; there's a `G` in `ggc-page.c`)

My favorite is currently "g", for ease of debugging a shared-library build
in gdb.

Parallel Universes vs Modularity
--------------------------------
Many things will gain a `universe&`.  Although this is good from a
state-removal perspective, there's a danger here that this could become
a big blob, or rats nest of interdependencies, where everything in the
compiler can access anything else in the compiler.

I think that having a `universe&` where you need it is sufficiently
useful that a "good intentions"/"consenting adults" approach will be
acceptable for the initial iteration of this work for mitigating
the above risk.

Ultimately we may want to pass in something more restrictive e.g. just
a `gc_heap&` so that objects don't get tightly coupled.


"universe" objects sit *below* garbage-collection
-------------------------------------------------
Although there's been some talk of removing GTY, I plan to work with the
existing code, without requiring other features to land, and that means
dealing with GC and PCH.

There are two possible ways in which universe instances could interact
with the GC:

  (a) have the universe instances be GC-managed: all parallel universes
      share the same heap, and rewriting the GC code to be thread-safe, or

  (b) have the universe manage GC, so that the state of GC is
      per-universe: each universe has its own GC heap, entirely
      independent of each other universe's GC heap.  You can't share GC
      pointers between universes.

I don't think (a) is feasible.

The GC is written with the assumption that it only runs at
explicitly-controlled times.

For example, the code is full of places where refs to GC-managed data are
stored on the *stack*, but there is no mechanism for tracking on-stack GC
roots during a mark-and-sweep.  In a multithreaded process using GCC's
code, if one thread wants to garbage-collect, all other threads would need
to also be at a location where it's safe to GC.

Hence (a) would require all threads to synchronize on GC-safe locations.

It would also require a substantial rewrite of PCH-handling, since PCH
files are essentially a dump of the state of the GC-heap.

It seems much simpler to me to go with (b): multiple independent GC-heaps.

Proof-of-concept patch posted as http://gcc.gnu.org/ml/gcc-patches/2013-06/msg00878.html

Callgraph objects
-----------------
I have an (unposted) patch which moves many of the `cgraph_` functions to
be methods of a new `class callgraph`.

See below in "Middle-end classes" for how this looks.

Status
^^^^^^
Not yet ready; remaining work:

  * integrate the class with GTY
  * integrate the class with "universe"

.. Note to self: my working copy for this aspect is
   `gcc-git-state-cleanup-cgraph`


Universe-specific state
-----------------------

New file gcc/universe.h which ultimately would declare something like this::

   class universe
   {
   public:
       /* Instance of the garbage collector.  */
       MAYBE_STATIC gc_heap *heap_;

       /* Instance of the callgraph.  */
       MAYBE_STATIC callgraph *cgraph_;

       /* Pass management.  */
       MAYBE_STATIC pipeline *passes_;

       /* Important objects.  */
       MAYBE_STATIC struct gcc_options global_options_;
       MAYBE_STATIC frontend *frontend_;
       MAYBE_STATIC backend *backend_;

       MAYBE_STATIC FILE * dump_file_;
       MAYBE_STATIC int dump_flags_;

       // etc

       MAYBE_STATIC location_t input_location_;

       /* State shared by many passes. */
       MAYBE_STATIC struct df_d *df_;
       MAYBE_STATIC redirect_edge_var_state *edge_vars_;

       /* Passes that have special state-handling needs.  */
       MAYBE STATIC mudflap_state *mudflap_;

   }; // class universe

   #if GLOBAL_BUILD
   /* Global singleton instance of the universe.  */
   extern universe the_uni;
   #endif

(it would be initially be empty, but would be built up field by field
as patches are accepted).

universe.h will likely be included by everything, so the universe's fields
have some indirection to avoid users of universe.h requiring other header
files, and thus everything requiring every header file.

The "universe" instance can be thought of as the "root" object of global
state:  if you have a `universe*` you can reach many other useful objects
directly.  Similarly, many objects have a reference back to their
`universe*`


Various kinds of pass-local state
---------------------------------
From a state-management perspective, there are (at least) these kinds of pass:

* Single-instance passes vs multiple-instances passes

* Passes that have their own source file vs shares their source file with
  other pass(es).

  For an example of passes sharing a source file, see
  `tree-vect-generic.c`: where two instances of pass_lower_vector_ssa
  and an instance of pass_lower_vector have shared state, which isn't
  visible to the rest of the compiler.

* Passes with no internal state.

  Examples include:

    * `stack-ptr-mod.c`: pass_stack_ptr_mod
    * `tree-ssa-ifcombine.c`: pass_tree_ifcombine
    * `tree-ssa-loop-ch.c`: pass_ch
    * `tree-ssa-phiprop.c`: pass_phiprop

* Passes in which the internal state is already encapsulated by passing
  around a ptr to a struct.

  Examples include:

    * `gimple-low.c`: `pass_lower_cf`, which uses `(struct lower_data *)`
    * `tree-stdarg.c`: `pass_stdarg`, which uses `(struct stdarg_info *)`

* Passes where there are static variables in the underlying .c file, but
  in which the state is fully cleaned at the start/end of each invocation
  of the pass (i.e. for each function, for non-IPA passes).

  I've been calling this pattern "per-invocation state".

  There are numerous such passes; some examples are:

    * `compare-elim.c`: pass_compare_elim_after_reload
    * `mode-switching.c`: pass_mode_switching
    * `tree-loop-distribution.c`: pass_loop_distribution
    * `ree.c`: pass_ree
    * `regcprop.c`: pass_cprop_hardreg
    * `tracer.c`: pass_tracer
    * `tree-loop-distribution.c`: pass_loop_distribution
    * `tree-ssa-copy.c`: pass_copy_prop
    * `tree-ssa-math-opts.c` (all 4 passes)
    * `tree-ssa-reassoc.c`: pass_reassoc
    * `tree-ssa-sink.c`: pass_sink_code
    * `tree-ssa-strlen.c`: pass_strlen
    * `tree-ssa-uncprop.c`: pass_uncprop

  I posted a patch for tracer.c as
  http://gcc.gnu.org/ml/gcc-patches/2013-05/msg01318.html
  and the followup:
  http://gcc.gnu.org/ml/gcc-patches/2013-05/msg01351.html
  gives a general way of dealing with these.

  Richard Henderson posted a couple of other approaches as:
  http://gcc.gnu.org/ml/gcc-patches/2013-05/msg01395.html
  and:
  http://gcc.gnu.org/ml/gcc-patches/2013-05/msg01415.html

* Per-invocation state as above, but where the lifetime of the state is
  localized to a subset of the functions within the pass.

  An example is `tree-loop-distribution.c`: pass_loop_distribution,
  which has state that only lives within calls to `ldist_gen` and below,
  which is only a part of the pass

  This pattern can be dealt with like per-invocation state, but we
  can restrict where the state lives to keep in contained.  In the
  above example, we could have a `class ldist_gen_state` to emphasize
  that this state only lives during this part of the pass.

  Other examples:

  * `tree-if-conv.c`: pass_if_conversion

* Passes with one-time-initialized state, which is private to the pass.

  Any examples?

  I had thought that `tree-profile.c` (pass_ipa_tree_profile) was one:
  the first time in it creates tree nodes that will be shared by the
  manipulation of every function the pass touches, but which aren't
  used outside of the pass' code.  However the creation hook can be
  called from `profile.c` so we have to expose this poking of the state
  in case the time of initialization affects the results.

* Passes with one-time-initialized state (which could perhaps be shared
  with other contexts?)

* Passes where the state may persist from invocation to invocation (e.g.
  stats)

* Passes with non-static state, visible to other parts of the compile
  (reginfo.c?)

* Passes with GTY(()) state.  See e.g. `tree-vect-generic.c`

* Passes that exists merely to cleanup other (global) state
  (e.g. `pass_ipa_free_lang_data`, `pass_release_ssa_names`)

* Source files with complicated interactions of state that don't easily
  fit into the above patterns.

  Examples:

    * `tree-mudflap.c` (where other parts of the compiler call into
      an API that shares state with the pass)

    * `tree-ssa-uninit.c`: pass_late_warn_uninitialized exposes its
      state via `ssa_undefined_value_p`

The approach I've proposed (tackling tracer.c) covers per-pass state
when there's only ever a single instance of the pass within a universe,
but I haven't yet posted how I plan to deal with per-pass state that's
shared between multiple pass instances.   For example, there are two
instances of "pass_vrp", which share the various states within
tree-vrp.c

One plan for dealing with these in a gcc-as-a-library setting is that
when the passes are created, the factory function is passed in a
pointer to the first instance of that pass within the current universe::

  extern opt_pass *
  make_pass_vrp (universe &uni, opt_pass *first_instance);

This pointer will be NULL for the first "pass_vrp" instance, and
subsequent instances will get the pointer to the first.  There's a
contract in the API between the manager and the passes that
first_instance will, if non-NULL, be an instance of the same subclass of
opt_pass that the function returns, so that make_pass_vrp can safely
cast it to the correct opt_pass subclass, and the details of the
opt_pass subclasses can stay encapsulated away inside their
individual .c files.

Another is similar, but instead passes have a clone method::

  class opt_pass
  {
  public:
    ...
    virtual opt_pass * clone() = 0;
    ...
  };

with this in tree-vrp.c::

  class pass_vrp : public gimple_opt_pass
  {
  public:
    pass_vrp(context &ctxt, pass_vrp *first_instance)
      : gimple_opt_pass(/*...snip...*/)

    /*...snip...*/

   opt_pass * clone() { return new pass_vrp (ctxt, this); }

    /*...snip...*/
  };

  extern opt_pass *
  make_pass_vrp (context &ctxt);
  /* this function makes the initial instance of the pass */


Then the first_instance gets responsibility for managing the pass state
(e.g. with a pass_vrp_state field), and all other instances can access
it - thus we have shared state, but the state is "local" to the universe::

  Universe A:                        Universe B:
  ===========                        ===========
  pass_vrp_0:A                       pass_vrp_0:B
              ↘                                  ↘
               pass_vrp_state:A                   pass_vrp_state:B
              ↗                                  ↗
  pass_vrp_1:A                       pass_vrp_1:B

(there are unicode arrow chars in the above "ascii" art, in case they're
not visible)

Once passes are C++ classes (automated), we could convert passes one at
a time to this model::

  /* State shared between multiple instances of pass_foo.  */
  class foo_state
  {
     /* Functions become MAYBE_STATIC methods of foo_state as necessary
        making most of them private, apart from the hooks called by
        the pass execution callback.  */

     /* Data become MAYBE_STATIC private fields of foo_state.  */
  };

  /* An instance of a pass (either the "main" one, or a "secondary"),
     with a reference to shared state.  */
  class pass_foo : public gimple_pass
  {
  protected:
     pass_foo(context &ctxt,
              foo_state &shared_state)

     /* Create secondary pass, sharing state with this one.
        All such clones will share state.  */
     opt_pass *clone() { return new pass_foo(ctxt, shared_state); }

  private:
     foo_state &shared_state;
  };

  /* The first pass to be created in a context "owns" the state.  */
  class main_pass_foo : public pass_foo
  {
  public:
     main_pass_foo(context &ctxt)
       : pass_foo(ctxt, shared_state)
     {}

  private:
     MAYBE_STATIC foo_state actual_state;
  };

  opt_pass *make_pass_foo (context &ctxt) { return main_pass_foo(ctxt); }

(maybe "stateful_pass_foo" rather than just "main_pass_foo"?  better naming?)

This gives us state shared between all instances of a pass within a
context/universe, but separate to instances of that pass in other universes,
and hidden from the rest of the code.


Sometimes state needs to be shared between multiple kinds of pass within a
context/universe.

An example is `tree-vect-generic.c`, where the single-instanced
pass_lower_vector and pair of pass_lower_vector_ssa instances share
state within their respective universes::


  Universe A:                        Universe B:
  ===========                        ===========
  pass_lower_vector:A────────────╮   pass_lower_vector:B────────────╮
  pass_lower_vector_ssa_0:A────╮ │   pass_lower_vector_ssa_0:B────╮ │
  pass_lower_vector_ssa_1:A──╮ │ │   pass_lower_vector_ssa_1:B──╮ │ │
                             ↓ ↓ ↓                              ↓ ↓ ↓
              lower_vector_state:A               lower_vector_state:B

To handle this case, I'm considering two approaches:

  * a variant on the above scheme (pass_vrp), in which the first instance
    of any pass within the group to be created owns the state, and
    instances of other kinds of pass manually look up that instance via the
    pipeline object.

    Example: if pass_foo is created first, then pass_bar can share state
    with it like this::

      opt_pass *make_pass_bar (context &ctxt)
      {
        /* Locate the shared state my hardcoding a reference to a pass
           that already has it: */
        foo_pass *reference_pass = ctxt.pipeline->pass_bar_1;
        gcc_assert (reference_pass);
        foo_state &shared_state = reference_pass->get_shared_state ();
        return new pass_bar (ctxt, shared_state);
      }

    An issue with this approach is that it relies on the reference pass
    being created before any instances of pass_bar, so if the passes get
    reordered there's extra work.  Though we could workaround that
    by creating passes in two phases: creating the passes, then wiring
    up the hierarchy.

  * Putting a reference to the shared state into the universe/context object
    and having the passes locate it there (either at creation, or when they
    run)

    An issue with this is that the universe object gains state classes for
    various specific passes, which seems a little clunky.

Note that in both cases, the GLOBAL_STATE build has empty state objects:
the MAYBE_STATIC means that everything is being done with globals.


GTY pass data
^^^^^^^^^^^^^
Some pass state includes GTY(()) data.  For example `asan.c` has::

  static GTY(()) tree asan_ctor_statements;

which is effectively a local within asan_finish_file, but is currently
exposed as above to ensure it gets marked in case a GC happens within
that function.

Passes have hooks for interacting with the GC - a way to solve the above
issue may be to place such objects into a pass state class (as above),
and to ensure that the pass's GC hooks visit the relevant data (perhaps
by adding GTY hooks to the state class - although it will typically not
be GC-allocated, merely have the ability to own GC-references).


Pass management
---------------
There will be a new `class pipeline` encapsulating pass management.

http://gcc.gnu.org/ml/gcc-patches/2013-04/msg00182.html

Passes become C++ classes
^^^^^^^^^^^^^^^^^^^^^^^^^

See the notes below under "Pass classes" to see what they look like.

Passes are not yet invoked on a specific function
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
The execute callback (now a vfunc) could gain a `function *` parameter.
Initially this would be `cfun`, but this would give us a way of eventually
eliminating `cfun`.

Plan: don't do this for this milestone (see notes of cfun below on the
difficulties here).

Passes "know" which universe they are in
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Passes are constructed with a `universe&`, making this information easily
accessible in the gate and execute hooks.

Remaining work
^^^^^^^^^^^^^^
The big issues remaining here are:

  * integrating with PCH
  * buy-in for having dynamically-allocated passes even in a "static
    build":

     * several hundred extra mallocs at start-up of less than 100 bytes
       each.  Potentially this can be worked around by using placement
       syntax, but is the extra ugliness worth the supposed speedup?
     * debuggability - having to go through the pass manager to get at
       data

How do you determine which universe you are in?
-----------------------------------------------
Every pass "knows" which universe it is in, so every "execute" hook can
easily determine which its universe, and put this into the per-pass state.
Hence the `universe*` is easily accessed during the top-level function
calls within optimization passes, and by anything that can access per-pass
state.

How to get at universe from deep within code that doesn't have easy access
to it?  (e.g. helper functions and macros)

LLVM solves this by having every type object have a universe*: you can
always easily find a type object.  This is probably too expensive
memory-wise to be acceptable to upstream gcc, so we need a different
approach.

Every type already has a context, from tree.h::

  #define TYPE_CONTEXT(NODE) (TYPE_CHECK (NODE)->type_common.context)

  struct GTY(()) tree_type_common {
     ...
     tree context;
     ...
  };

so perhaps such contexts could gain a universe*, or the root context could
gain one.   For the non-shared case you'd be doing work to access
the universe, then ignoring this - so universe-lookup could be done behind
a macro::

  /* Macro for getting a (universe &) from a type. */
  #if SHARED_BUILD
    #define GET_UNIVERSE(TYPE)  get_universe_from_type((TYPE))
  #else
    /* Access the global singleton: */
    #define GET_UNIVERSE(type)  (the_uni)
  #endif

Alternatively, we could use TLS for this - though I'd prefer to avoid
relying on TLS (since it means that client code can't share universes
between threads)::

  /* Macro for getting a (universe &) */
  #if SHARED_BUILD
    /* Read a thread-local pointer: */
    #define GET_UNIVERSE()  (*uni_ptr)
  #else
    /* Access the global singleton: */
    #define GET_UNIVERSE()  (the_uni)
  #endif

  #if SHARED_BUILD
     extern __thread universe *uni_ptr;
  #else
     extern universe the_uni;
  #endif

This approach has the advantage of relative simplicity, and is efficient
for the non-shared case (where the result of GET_UNIVERSE() will be
effectively ignored, as everything will be going through "static").

Plan: go with the TLS approach above for the places that need it.


Interaction with GCC plugins
----------------------------

Currently-existing GCC plugins are expecting to be run from inside a
traditional GCC where there is a single instance of state, and I intend
to continue that model.

The shared-library approach supports reusing parts of GCC code to build
other kinds of tools, and plugins may or may not make sense in such tools
(perhaps being initialized once per-context?)

However this is out-of-scope for this iteration.

(perhaps this is analagous to embedding vs extending in the Python world;
see http://docs.python.org/2/extending/embedding.html).


Tools
-----
I've been writing scripts to make it easier to automatically refactor the
GCC code (e.g. respecting whitespace conventions, whilst not touching
whitespace in lines we don't touch, generating ChangeLogs etc):

  https://github.com/davidmalcolm/gcc-refactoring-scripts


GCC 4.9 schedule
----------------
One other concern is how all of this lines up with GCC 4.9's schedule.
These big internal reorganizations need to happen in stage 1 of the
upstream schedule, right?  Not sure where that is calendar-wise, but my
hope is to get the big reorg changes in sooner rather than later.

`SWITCHABLE_TARGET`
-------------------
TODO

